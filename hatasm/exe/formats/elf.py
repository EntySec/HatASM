"""
This format requires HatAsm: https://github.com/EntySec/HatAsm
Current source: https://github.com/EntySec/HatAsm
"""

import struct

from hatasm.lib.format import Format


class HatAsmFormat(Format):
    elf_magic = [
        b"\x7f\x45\x4c\x46"
    ]

    elf_headers = {
        'armle': (
            b"\x7f\x45\x4c\x46\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            b"\x02\x00\x28\x00\x01\x00\x00\x00\x54\x80\x00\x00\x34\x00\x00\x00"
            b"\x00\x00\x00\x00\x00\x00\x00\x00\x34\x00\x20\x00\x01\x00\x00\x00"
            b"\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00"
            b"\x00\x80\x00\x00\xef\xbe\xad\xde\xef\xbe\xad\xde\x07\x00\x00\x00"
            b"\x00\x10\x00\x00"
        ),
        'mipsbe': (
            b"\x7f\x45\x4c\x46\x01\x02\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            b"\x00\x02\x00\x08\x00\x00\x00\x01\x00\x40\x00\x54\x00\x00\x00\x34"
            b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x34\x00\x20\x00\x01\x00\x00"
            b"\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x40\x00\x00"
            b"\x00\x40\x00\x00\xde\xad\xbe\xef\xde\xad\xbe\xef\x00\x00\x00\x07"
            b"\x00\x00\x10\x00"
        ),
        'mipsle': (
            b"\x7f\x45\x4c\x46\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            b"\x02\x00\x08\x00\x01\x00\x00\x00\x54\x00\x40\x00\x34\x00\x00\x00"
            b"\x00\x00\x00\x00\x00\x00\x00\x00\x34\x00\x20\x00\x01\x00\x00\x00"
            b"\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00"
            b"\x00\x00\x40\x00\xef\xbe\xad\xde\xef\xbe\xad\xde\x07\x00\x00\x00"
            b"\x00\x10\x00\x00"
        ),
        'x86': (
            b"\x7f\x45\x4c\x46\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            b"\x02\x00\x03\x00\x01\x00\x00\x00\x54\x80\x04\x08\x34\x00\x00\x00"
            b"\x00\x00\x00\x00\x00\x00\x00\x00\x34\x00\x20\x00\x01\x00\x00\x00"
            b"\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x80\x04\x08"
            b"\x00\x80\x04\x08\xef\xbe\xad\xde\xef\xbe\xad\xde\x07\x00\x00\x00"
            b"\x00\x10\x00\x00"
        ),
        'aarch64': (
            b"\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            b"\x02\x00\xb7\x00\x00\x00\x00\x00\x78\x00\x40\x00\x00\x00\x00\x00"
            b"\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            b"\x00\x00\x00\x00\x40\x00\x38\x00\x01\x00\x00\x00\x00\x00\x00\x00"
            b"\x01\x00\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            b"\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00"
            b"\xef\xbe\xad\xde\x00\x00\x00\x00\xef\xbe\xad\xde\x00\x00\x00\x00"
            b"\x00\x10\x00\x00\x00\x00\x00\x00"
        ),
        'x64': (
            b"\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            b"\x02\x00\x3e\x00\x01\x00\x00\x00\x78\x00\x40\x00\x00\x00\x00\x00"
            b"\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            b"\x00\x00\x00\x00\x40\x00\x38\x00\x01\x00\x00\x00\x00\x00\x00\x00"
            b"\x01\x00\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
            b"\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00"
            b"\x41\x41\x41\x41\x41\x41\x41\x41\x42\x42\x42\x42\x42\x42\x42\x42"
            b"\x00\x10\x00\x00\x00\x00\x00\x00"
        )
    }

    def __init__(self) -> None:
        super().__init__({
            'Name': 'Executable and Linkable Format',
            'Description': (
                'Pack machine code into an ELF file.'
            ),
            'Arch': self.elf_headers.keys(),
            'Platform': 'linux'
        })

    def run(self, arch, data):
        if data[:4] in self.elf_magic:
            return data

        headers = self.elf_headers

        for header_arch in headers:
            if arch != header_arch:
                continue

            elf = headers[header_arch] + data

            if elf[4] == 1:
                if str(arch).endswith('be'):
                    p_filesz = struct.pack(">L", len(elf))
                    p_memsz = struct.pack(">L", len(elf) + len(data))
                else:
                    p_filesz = struct.pack("<L", len(elf))
                    p_memsz = struct.pack("<L", len(elf) + len(data))
                content = elf[:0x44] + p_filesz + p_memsz + elf[0x4c:]

            elif elf[4] == 2:
                if str(arch).endswith('be'):
                    p_filesz = struct.pack(">Q", len(elf))
                    p_memsz = struct.pack(">Q", len(elf) + len(data))
                else:
                    p_filesz = struct.pack("<Q", len(elf))
                    p_memsz = struct.pack("<Q", len(elf) + len(data))
                content = elf[:0x60] + p_filesz + p_memsz + elf[0x70:]

            else:
                raise RuntimeError("ELF header corrupted!")
            return content

        raise RuntimeError("Failed to find compatible ELF header!")
